SELENIUM, PROTRACTOR (built on selenium: cross browser testing), CYPRESS (built on selenium: mainly for Chrome browser)
// For Table cell locator using table label ID
private WebElement editableTableCell(final String tableId, final String columnName, final int rowNumber) {
	return driver.findElement(By.cssSelector("#" + tableId + " tbody tr:nth-child(" + rowNumber + ") td:nth-child("
			+ getColumnIndex(columnName) + ") input")); //it could have th , so check for it.
	}
	
	private int getColumnIndex(final String columnName) {
		int index = 0;
		for (WebElement colNum : driver.findElements(By.cssSelector("thead th"))) {
			index = index + 1;
			if (colNum.getText().equalsIgnoreCase(columnName)) {
				return index;
			}
		}
		return -10;
	}
	
 public List<String> getColumnData(final List<WebElement> columnWebElement) {
 final List<String> cellData = new ArrayList<>();
 if (columnWebElement.size() > 0) {
    for (final WebElement cell : columnWebElement) {
	if (cell != null) { 
	    new MouseFunctions(myDriver).tabKey();
	    String data = getAttribute(cell, ATTRIBUTE_VALUE) == null ? cell.getText() : cell.getAttribute(ATTRIBUTE_VALUE);
	    if (!data.equals("")) {
		cellData.add(data);
	    } else {
		cellData.add("''");  
	    }
	}
    }
 } else if (columnWebElement.size() < 1) {
    Utility.logWarning("Get Column Data", "The specified column seems not to have an active cell to verify");
 }
 return cellData;
 }
    
    //Enum returning String
 public enum ENUMname{

    VALUE1 {
        @Override
        public String toString() {
            return EXPECTED_VALUE1;
        }
    },
     VALUE2 {
        @Override
        public String toString() {
            return EXPECTED_VALUE2;
        }
    }
}

 private boolean isReadOnly(final @NotNull WebElement webElement){
     return commonFunctions.waitForElementToAppear(webElement).getAttribute("class").contains("readOnlyInfo") ? true : false;
 }
    
 String getElementDisplayedText(WebElement webElement) {
     return isReadOnly(webElement) ? webElement.getText() : webElement.getAttribute(ATTRIBUTE_VALUE);

// Convert HashMap<String, Object> to HashMap<String, String>
// Map<String,Object> map = new HashMap<>();
        Map<String,String> newMap = new HashMap<String,Object>().entrySet().stream()
             .collect(Collectors.toMap(Map.Entry::getKey, e -> (String)e.getValue()));

 public JavaScriptFunctions waitForPageToReady() {
        for (int i = 0; i < 25; i++) {
            if (getJsExecutor().executeScript("return document.readyState").toString().equals("complete")) {
                return this;
            }
        }
        return this;
    }
    
    private Wait<WebDriver> wait(int waitTimeInSecond){
    	return new FluentWait<>(driver).withTimeout(Duration.ofSeconds(waitTimeInSecond))
    					.pollingEvery(Duration.ofSeconds(1)).ignoring(NoSuchElementException.class);
    }

//LambDa Expression for String to Object
private static BigDecimal convertStringToBigDecimal(final String strValue) {
        if (!Utility.isNullOrWhitespaces(strValue)) {
            final String tmp = strValue.replaceAll("[^0-9.]", "");
            return new BigDecimal(tmp);
        }
        return null;
    }
    
 //Ternary with StringBuilder   
public String cellRowData(final String tableDomId, final int rowNumber) {
	return new StringBuilder()
			.append(getCellData(tableDomId, columnName, rowNumber).equals("") ? "-- "
				: getCellData(tableDomId, columnName, rowNumber) + " ").toString();
}

public String getCellData((final String tableId, final String columnName, final int rowNumber) {
		return (!nonEditableCell(tableId, columnName, rowNumber).getAttribute("class").contains("input"))
				? nonEditableCell(tableId, columnName, rowNumber).getText() 
						: editableCell(tableId, columnName, rowNumber).getAttribute("value");
	}


public String getSumOfAmountValueEntered(List<String> amountColumn) {
	if (amountColumn.isEmpty()) {
		return BigDecimal.ZERO.toString();
	} else {
		BigDecimal totalAmount = BigDecimal.ZERO;
		for (final String amount : amountColumn) {
			if(!Utility.isNullOrWhitespaces(amount)){
				totalAmount =totalAmount.add(new BigDecimal(amount.replace("$", "").replaceAll(",", "")));
			}
		}
	return NumberFormat.getCurrencyInstance(getLocaleFromCurrency("USD")).format(totalAmount.floatValue());
	}
 }
 
 private static Locale getLocaleFromCurrency(String strCode) {
    for (final Locale locale : NumberFormat.getAvailableLocales()) {
	final String code = NumberFormat.getCurrencyInstance(locale).getCurrency().getCurrencyCode();
	if (strCode.equals(code)) {
	    return locale;
	}
    }  
    return null;
}

public List<String> getTableColumnData(final String tableHtmlId, final String columnName) {
		final List<String> editableCell = new ArrayList<>();
		final List<String> nonEditableCell = new ArrayList<>();
		List<WebElement> columns = editableColumn( tableHtmlId,  columnName);

		if (!columns.isEmpty()) {
			columns.forEach(cell -> {
				if (cell.getAttribute(ATTRIBUTE_VALUE).equals("")) { 
					editableCell.add("''");
				} else {
					editableCell.add(cell.getAttribute(ATTRIBUTE_VALUE));					
				}
			});	
		} else {
			nonEditableColumn( tableHtmlId,  columnName).forEach(cell -> {
						if (cell.getText().equals("")) {
							nonEditableCell.add("''");
						} else {
							nonEditableCell.add(cell.getText());
						}
					});
		}
		return CollectionUtils.isEmpty(nonEditableCell) ? editableCell : nonEditableCell;
	}


public class Listeners extends TestListenerAdapter {

	public ExtentHtmlReporter htmlReporter;
	public ExtentReports extent;
	public ExtentTest test;
//	public ITestResult result;

	/*
	 * @AfterMethod() public void captureStatus(ITestResult result) { if
	 * (ITestResult.SUCCESS == result.getStatus()) { test.pass(result.getName() +
	 * " Passed"); test.log(Status.PASS, result.getName() + " test passed"); }
	 * 
	 * else if (ITestResult.STARTED == result.getStatus()) { test.log(Status.INFO,
	 * result.getName() + " test started"); }
	 * 
	 * else if (ITestResult.SKIP == result.getStatus()) { test.log(Status.SKIP,
	 * result.getName() + " test is skipped and the reason is:- " +
	 * result.getThrowable()); }
	 * 
	 * else if (ITestResult.FAILURE == result.getStatus()) { test.log(Status.ERROR,
	 * result.getName() + " test failed! And the reason is: " +
	 * result.getThrowable()); } }
	 */

	/**
	 * @param method
	 */
	public  void getTestMethodsInformation(Method method) {
		test = extent.createTest(method.getName(), "is being executed").assignAuthor("Oludare M Eniola").createNode(method.getName() + " Test Result Status");
	//	test = extent.createTest(method.getName(), "is being executed").createNode(method.getName() + " Test Result Status");
}
	
	public void onStart(ITestContext testContext) {
		htmlReporter = new ExtentHtmlReporter(System.getProperty("user.dir") + "/Reports/myReport.html");
		// htmlReporter.loadXMLConfig(new File(useFileData("extent_config_xml")));
		htmlReporter.config().setDocumentTitle("Test Execution - ExtentReports");
		htmlReporter.config().setReportName("API RestAssured Automation Test Report");
		htmlReporter.config().setTheme(Theme.DARK); // Theme background - dark, standard
		htmlReporter.config().setTimeStampFormat("mm/dd/yyyy hh:mm:ss a"); // set timeStamp format
		htmlReporter.loadXMLConfig("C:\\Users\\Da Novenos\\eclipse-workspace\\RestAssuredAPITestingFramework\\src\\main\\java\\com\\apitest\\utility\\extent-config.xml");
		// htmlReporter.config().setTestViewChartLocation(ChartLocation.TOP); // BOTTOM

		// Additional information that makes our report looks nice
		 if (extent == null) {
		extent = new ExtentReports();
		 }
		extent.setSystemInfo("Host Name", "Novenos IT Solutions Inc.");
		extent.setSystemInfo("Project Name", "Employee Database API project");
		extent.setSystemInfo("Environment", "QA/Automation Testing");
		extent.setSystemInfo("Version", "V-1.0.0");
		extent.setSystemInfo("OS", "Windows-10");
		extent.attachReporter(htmlReporter);
	}

	public void onTestSuccess(ITestResult result) {
		test = extent.createTest(result.getName());
		test.log(Status.PASS, result.getName() + " test passed");
	}

	public void onTestFailure(ITestResult result) {
		test = extent.createTest(result.getName());
		test.log(Status.FAIL, result.getName() + " test failed! ---> " + result.getThrowable());
	}

	public void onTestSkip(ITestResult result) {
		test = extent.createTest(result.getName());
		test.log(Status.SKIP, result.getName() + " was skipped.");
	}

	public void onFinish() {
		extent.flush();
	}

}


public class PageLinksFunction {

    private static final Logger LOGGER = LoggerFactory.getLogger(PageLinksFunction.class);

    public static WebDriver myDriver;

    public PageLinksFunction(final WebDriver driver) {
        myDriver = driver;
    }

    public void getAllPageLinks() {
        final List<WebElement> links = myDriver.findElements(By.tagName("a"));
        LOGGER.info("The total number of links on this web page is: " + links.size());
        for (final WebElement ele : links) {
            final String url = ele.getAttribute("href");
            verifyActiveLink(url);
        }
    }

    private static void verifyActiveLink(final String urlLink) {
        try {
            final URL url = new URL(urlLink);
            final HttpURLConnection httpConnectUrl = (HttpURLConnection) url.openConnection();
            httpConnectUrl.setConnectTimeout(3000);
            httpConnectUrl.connect();
            if (httpConnectUrl.getResponseCode() == 200) {
                LOGGER.info(urlLink + " - " + httpConnectUrl.getResponseMessage());
            }
            if (httpConnectUrl.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {
                LOGGER.info(urlLink + " - " + httpConnectUrl.getResponseMessage() + " - "
                                + HttpURLConnection.HTTP_NOT_FOUND);
            }
        } catch (final Exception e) {
            LOGGER.error("Error Occured", e);
        }
    }
}

    
    
    BrowserType getBrowserEnum(final String browser) { // BrowserType is an enum
        final String msg = "Get browser enum for: {}";
        logger.trace("Get browser enum for: {}", msg);
        switch (browser.toUpperCase()) {
            case "CHROME":
                logger.trace(msg, BrowserType.CHROME);
                return BrowserType.CHROME;
            case "EDGE":
                logger.trace(msg, BrowserType.EDGE);
                return BrowserType.EDGE;
            case "FIREFOX":
                logger.trace(msg, BrowserType.FIREFOX);
                return BrowserType.FIREFOX;
            case "IE":
                logger.trace(msg, BrowserType.IE);
                return BrowserType.IE;
            case "CHROME_HEADLESS":
                logger.trace(msg, BrowserType.CHROME_HEADLESS);
                return BrowserType.CHROME_HEADLESS;
            case "FIREFOX_HEADLESS":
                logger.trace(msg, BrowserType.FIREFOX_HEADLESS);
                return BrowserType.FIREFOX_HEADLESS;
            default:
                logger.trace(msg, BrowserType.IE);
                return BrowserType.IE;
        }
    }
    
    String propertiesFileData(final String configFileData) {
        return FrameworkConfig.properties.getProperty(configFileData);
    }
    
    //Data provider
    protected String setWorkBook(final String workName) {
        final StringBuilder sb = new StringBuilder();
        // sb.append(System.getProperty("user.dir")).append(FrameworkConfig.propertiesFileData(TESTDATAPATH))
        sb.append(FrameworkConfig.propertiesFileData(TESTDATAPATH)).append(workName);
        return sb.toString();
    }
    
    @DataProvider(name = "providerName")
    public Object[][] MethodName() {
        return new SpreadSheetHandler(setWorkBook("WorkBookName"), "SheetName", false).getTestData();
    }
    
    //Variable declaration
    public FileInputStream file = null;
    public XSSFWorkbook workbook = null;
    public XSSFSheet sheet = null;
    protected String pathToWorkbookLocation = null;
    protected XSSFRow row = null;
    protected XSSFCell cell = null;
    protected Row rows = null;
    protected Cell cells = null;
    
    //Constructor
    SpreadSheetHandler(final String workBook, final String excelSheet, final boolean isSheetTypeIndex) {
        this.pathToWorkbookLocation = workBook;
        try {
            file = new FileInputStream(new File(workBook));
            workbook = new XSSFWorkbook(file);
            if (isSheetTypeIndex) {
                final int index = Integer.parseInt(excelSheet);
                sheet = workbook.getSheetAt(index);
            } else {
                sheet = workbook.getSheet(excelSheet);
            }
            file.close();
        } catch (final Exception e) {
            logger.error("Error Occured", e);
        }
    }
    
    //Data retrieval
     public Object[][] getTestData() {

        final int totalRow = sheet.getLastRowNum();
        final int totalColumn = sheet.getRow(0).getLastCellNum();
        final Object[][] dataSets = new Object[totalRow][1];
        HashMap<Object, Object> tableData = null;
        boolean rowIsNotEmpty = false;
        int nonEmptyRows = 0;

        for (int i = 0; i < totalRow; i++) {
            tableData = new HashMap<>();
          
            for (int j = 0; j < totalColumn; j++) {
                final XSSFRow currentRow = sheet.getRow(i + 1);
                XSSFCell xssfcell = null;
                if (currentRow != null) {
                    xssfcell = sheet.getRow(i + 1).getCell(j);
                    if (xssfcell != null && xssfcell.toString().trim().length() > 0) {
                        rowIsNotEmpty = true;
                        tableData.put(sheet.getRow(0).getCell(j).toString(), xssfcell.toString());
                    } else {
                        tableData.put(sheet.getRow(0).getCell(j).toString(), "");
                    }
                }
            }

            if (rowIsNotEmpty) {
                nonEmptyRows++;
                dataSets[i][0] = tableData;
            }
        }

        final Object[][] validDataSets = new Object[nonEmptyRows][1];
        if (nonEmptyRows > 0) {
            for (int r = 0; r < nonEmptyRows; r++) {
                validDataSets[r][0] = dataSets[r][0];
            }
        }
        return validDataSets;
    }
    
    /*  Initializing and insert config.properties file with its value(s) at run time. */
	public static String propertiesFileData(String configFileData) {
	return ConfigurationDataSource.getProperties().getProperty(configFileData);
	} 
    
    private By button(String displayedButtonText){
    	return By.cssSelector("input.button[value='" + displayedButtonText + "']");
    }
    
    //CSV file manipulation
    private static String withCode(final CSVRecord record) {
		  return String.format("%s%s.%s", record.get(File.SP_HEADER.value), record.get(File.AID_HEADER.value).replaceFirst("0", ""), 
						record.get(File.MAIN_HEADER.value), record.get(File.SUB_HEADER.value).replaceFirst("^0+(?!$)", ""));
	 }
	
	 private static String withoutCode(final CSVRecord record) {
		 return String.format("%s%s%s", record.get(File.SP_HEADER.value), record.get(File.AID_HEADER.value).replaceFirst("0", ""), 
						record.get(File.AVAIL_TYP_CD_HEADER.value), record.get(File.MAIN_HEADER.value));
	 }
	 
	 public static String constructString(final CSVRecord record) {
		/*if(record.get(File.ENUM_HEADER.value).equals("integerValue")) {
			return record.get(File.ENUM_HEADER.value) == null ? withoutCode(record) : withoutCode1(record);
		}
		return record.get(File.ENUM_HEADER.value) == null ? withCode(record) : withCode1(record) ;*/
		if(record.get(File.ENUM_HEADER.value).equals("000")) {
			return withoutCode(record);
		}
		return withCode(record);
	 }  
	 
	 public static String constructDetailFieldNames(final int index, final String attribute) {
		return String.format("detail[%d].%s", index, attribute);
	}
	
	private Wait<WebDriver> wait(int waitTimeInSecond){
    	return new FluentWait<>(driver).withTimeout(Duration.ofSeconds(waitTimeInSecond))
    					.pollingEvery(Duration.ofSeconds(1)).ignoring(NoSuchElementException.class);
    }
    
    private className selectDropdownMenu(final String stringValue){
        dropdownMenu(driver.findElement(By.name("domeName1"))).selectByVisibleText(stringValue.split("/")[0]);
        dropdownMenu(driver.findElement(By.name("domeName2"))).selectByVisibleText(stringValue.split("/")[1]);
	dropdownMenu(driver.findElement(By.name("domeName3"))).selectByVisibleText(new StringBuilder()
   	   		.append(stringValue.split("0")[0]).append(stringValue.substring(stringValue.length()-3)).toString());
		return this;
	}
    
    public static String constructString(final CSVRecord record) {
		if(record.get(File.ENUM_HEADER.value).equals("000")) {
			return withoutCode(record);
		}
		return withCode(record);
	}
    
  //Regulare expression for number validation
  Integer checkIfNumeric(final String strData) {
        if (strData.matches("[0-9]+")) {
            return Integer.parseInt(strData);
        }
        return null;
    }
    
	private className populateTable(final String filePath) throws IOException {
		
		int index = 0;
		for(CSVRecord record : readCSV(filePath)) {
			int maxIndex = index + 1;
			for(int i = index; i <= maxIndex; i++) {
				enterValue(element(i, "elementDomString"), record.get(ENUM.VALUE.value));
				// for even row number (i)
				if(i % 2 == 0) { 
					enterValue(element(i, "elementDomString")), inputValue);
				} else {
				// for odd row number (i)
					enterValue(element(i, "elementDomString")), inputValue);
				}
			}
			index = maxIndex + 1;
		}
		return this;
	}
	
	private className populate_String_Table(final String filePath) throws IOException {
		//Modify to use lombok and pass the value at run time
		int index = 0;
		for (CSVRecord record : readCSV(filePath)) {
			String csvString = constructString(record);
			int maxIndex = index + 1;
			
			for(int i = index; i <= maxIndex; i++) {
			if(i % 2 == 0) {
				enterValue(element(i, "elementDomString")), csvString);
				enterAmount((maxIndex == (i + 1)) ? true : false, i, ENUM.VALUE2.value);
			} else {
				enterValue(tableMethodName(i, ENUM.VALUE2.value), csvString);
				enterAmount((maxIndex == (i + 1)) ? true : false, i, String
								.valueOf(Double.parseDouble(ENUM.VALUE1.value)+Double.parseDouble(ENUM.VALUE2.value)));
			    }
		    }
		index = maxIndex + 1;
		}
		return this;
	}
	
   private className inputField(final boolean true, final int index, final String value) {
		if (true) {
			enterValue(tableMethodName(index, ENUM.VALUE1.field), value);
		} else {
			enterValue(tableMethodName(index, ENUM.VALUE2.field), value);
		}
		return this;
	}
	
    public static CSVParser readCSV(final String path) throws IOException {
	//For csv file with column labels/headers
		return new CSVParser(new FileReader(path), CSVFormat.DEFAULT.withHeader());
	}
	
     // ternary	
     private WebElement stmtLocator(String value, int row, int cell){
        return	value.equalsIgnoreCase("expectedValue") ?
    	driver.findElement(By.cssSelector("cssSeleoctor:nth-child(" + ( x + row) + ") > td:nth-child(y)")) : 
    	driver.findElement(By.cssSelector("cssSeleoctor:nth-child(" +( z + row) + ") td:nth-child(" + cell + ")"));
    }
    
    private WebElement tableName(final int rowNumber, final String cellDomName){
    	return driver.findElement(By.name(constructDetailFieldNames(rowNumber, cellDomName)));
    }
    
    private CSVRecord getRecord(final String csvFile, final int recordIndex) throws IOException{
    	return readCSV(ENUM.CSV_FILENAME.value).getRecords().get(recordIndex);
    }
	
	private className enterValue(final WebElement element, final String value){
    	waitUntilElementIsVisible(5, element).sendKeys(Keys.chord(Keys.CONTROL, "a"));
    	element.sendKeys(Keys.BACK_SPACE);
    	element.sendKeys(value);
    	new Actions(driver).sendKeys(Keys.TAB).perform();
    	return this;
    }
    
     private className csvValueAssertion(String transactionType) throws IOException{    	
    	if(transactionType.equalsIgnoreCase("condition1")){
    		for(int i = 0; i < readCSV(ENUM.CSV_FILENAME.value).getHeaderMap().size(); i++){
    			int x = 0;
    			for(int j = 3; j < 11 ; j++){
				   if(i < readCSV(ENUM.CSV_FILENAME.value).getRecords().size()){
					    Assert.assertEquals(stmtLocator("conditon1", i , j).getText(), 
					    	    getRecord (ENUM.CSV_FILENAME.value, i).get(x));			    
					    LOGGER.info("Account statement table column " + readCSV(ENUM.CSV_FILENAME.value).
					    	    getHeaderNames().get(x)+ " value: '" + stmtLocator("cgac", i , j).getText() + 
					    	    "' <===> CSV file value: '" + getRecord(ENUM.CSV_FILENAME.value, i).get(x) + "'");
				    }	
				    x = x+1;			   
			    }
    		}
    	} else if(transactionType.equalsIgnoreCase("string")){
    		Assert.assertEquals(stmtLocator("String", 1, 0).getText(), 
    						constructString(getRecord(ENUM.CSV_FILENAME.value, 0)));
    		LOGGER.info("csv file row 1 string value: "+ constructString(getRecord(ENUM.CSV_FILENAME.value, 0)));
    		Assert.assertEquals(stmtLocator("string", 2, 0).getText(), 
    						constructString(getRecord(ENUM.CSV_FILENAME.value, 1)));
    		LOGGER.info("csv file row 2 string value: "+ constructString(getRecord(ENUM.CSV_FILENAME.value, 1)));
    	}
    	return this;
	}
	
    
    //String to array conversion
    List<String> stringToArray(final String stringValue) {
        return new ArrayList<>(Arrays.asList((stringValue.equals("") ? "''" : stringValue).split(",")));
    }
    
    //Lambda expression (loop)
    arrayData.stream().filter(element -> element.getText().equals(value)).findFirst().get(); (search an array and pick first match)
    arrayData.stream().anyMatch(element -> (element.substring(0).contains("character")) (search an array list and pick any match)
    arrayData.forEach(variable -> verifyVariablePresence(arrayData)); (loop through an array list one by one to the end)
    
    =============================================================================================================================
// https://github.com/dequelabs/axe-selenium-java/blob/develop/src/test/java/com/deque/axe/ExampleTest.java    
import com.deque.axe.AXE;
import io.github.bonigarcia.wdm.DriverManagerType;
import io.github.bonigarcia.wdm.WebDriverManager;
import lombok.extern.slf4j.Slf4j;
import enums.userRole;
import interfaces.interfaceName;
import package.class1;
import org.json.JSONArray;
import org.json.JSONObject;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxDriverLogLevel;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.testng.annotations.*;
import java.net.URL;

import static enumsPackage.EnumName.EnumMethodOrVariable;
import static org.testng.AssertJUnit.assertTrue;

@Slf4j
public class axe508cTests {
    private static final String FIREFOX_PATH = "pathToFirefox .exe file\\firefox.exe";
    private static WebDriver driver;
    private Test test;

    private static final URL scriptUrl = ClassNameStartingWithPackageFullPath.class.getResource("/axe.min.js");

    @BeforeTest
    static void setupAll() {
        final FirefoxOptions options = new FirefoxOptions();
        options.setBinary(FIREFOX_PATH);
        options.setAcceptInsecureCerts(true);
        options.setLogLevel(FirefoxDriverLogLevel.INFO);
        WebDriverManager.getInstance(DriverManagerType.FIREFOX)
                .browserPath(FIREFOX_PATH)
                .version("0.24.0")
                .proxy("h1proxy.frb.org:8080")
                .setup();
        driver = new FirefoxDriver(options);
    }

    @BeforeMethod
    void setUpEach() {
        driver.get("url");
        driver.manage().window().fullScreen();//.maximize();
        atmPo = new AtmPOv2(driver, userRole);
    }

    @Test
    void homePage508c() {
        JSONObject responseJSON = new AXE.Builder(driver, scriptUrl).analyze();
        JSONArray violations = responseJSON.getJSONArray("violations");

        if (violations.length() == 0) {
            assertTrue("No violations found", true);
        } else {
            AXE.writeResults("tryAxeCore", responseJSON);
            assertTrue(AXE.report(violations), false);
        }
    }

    @Test
    void createPage508c() {
        test.methodName(Class page title);
        JSONObject responseJSON = new AXE.Builder(driver, scriptUrl).analyze();
        JSONArray violations = responseJSON.getJSONArray("violations");
        if (violations.length() == 0) {
            assertTrue("No violations found", true);
        } else {
            AXE.writeResults("tryAxeCore", responseJSON);
            assertTrue(AXE.report(violations), false);
        }
    }

    @Test
    void ConfirmationPage508c() {
        driver.get("entered data detail page url/view;id= uniqueID");
        try {
            Thread.sleep(3000);
        } catch (InterruptedException ie) {

        }
        JSONObject responseJSON = new AXE.Builder(driver, scriptUrl).analyze();
        JSONArray violations = responseJSON.getJSONArray("violations");
        if (violations.length() == 0) {
            assertTrue("No violations found", true);
        } else {
            AXE.writeResults("tryAxeCore", responseJSON);
            assertTrue(AXE.report(violations), false);
        }
    }

    @AfterMethod
    void tearDownEach() {
        testBase.logOff();
    }

    @AfterTest
    void tearDownAll() {
        driver.quit();
    }
}

========================================================================================
    
    //Extent Report
<?xml version="1.0" encoding="UTF-8"?>
<extentreports>
    <configuration>
        <!-- report theme -->
        <!-- standard, dark -->
        <theme>standard</theme>
    
        <!-- document encoding -->
        <!-- defaults to UTF-8 -->
        <encoding>UTF-8</encoding>
        
        <!-- protocol for script and stylesheets -->
        <!-- defaults to https -->
        <protocol>https</protocol>
        
        <!-- title of the document -->
        <documentTitle>Extent</documentTitle>
        
        <!-- report name - displayed at top-nav -->
        <reportName>Automation Report By CARS Automation Team</reportName>
        
        <!-- location of charts in the test view -->
        <!-- top, bottom -->
        <testViewChartLocation>bottom</testViewChartLocation>
		
        <!-- custom javascript -->
        <scripts>
            <![CDATA[
                $(document).ready(function() {
                    
                });
            ]]>
        </scripts>
        
        <!-- custom styles -->
        <styles>
            <![CDATA[
                
            ]]>
        </styles>
    </configuration>
</extentreports>


# fileName.properties
key : value
key = value # another alternative


<!-- logback.xml comment -->
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
       <appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>test-output/logs/test.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- rollover monthly -->
            <fileNamePattern>system-%d{yyyy-MM}.log.zip</fileNamePattern>
            <maxHistory>12</maxHistory>
            <totalSizeCap>3GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%-26(%d [%-5level]) %logger{35} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <root level="info">
        <appender-ref ref="ROLLING" />
    </root>
     <root level="info">
        <appender-ref ref="STDOUT" />
    </root>
----------------------------------------------------------------------------------------

<!-- Log Back  dependency -->
 <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>

  <!--  configure slf4j binding -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>

<!--  Driver manager -->
	<dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>3.4.0</version>
            <scope>test</scope>
        </dependency>

<!-- 508 compliance -->
	<dependency>
            <groupId>com.deque</groupId>
            <artifactId>axe-selenium</artifactId>
            <version>3.0</version>
            <scope>test</scope>
        </dependency>
        
  <!-- https://mvnrepository.com/artifact/org.testng/testng -->
	<dependency>
		<groupId>org.testng</groupId>
		<artifactId>testng</artifactId>
		<version>6.14.3</version>
		<scope>test</scope>
	</dependency>

<!-- https://mvnrepository.com/artifact/org.apache.poi/poi -->
	<dependency>
		<groupId>org.apache.poi</groupId>
		<artifactId>poi</artifactId>
		<version>4.1.0</version>
	</dependency>


	<!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml -->
	<dependency>
		<groupId>org.apache.poi</groupId>
		<artifactId>poi-ooxml</artifactId>
		<version>4.1.0</version>
	</dependency>


	<!-- https://mvnrepository.com/artifact/com.aventstack/extentreports -->
	<dependency>
		<groupId>com.aventstack</groupId>
		<artifactId>extentreports</artifactId>
		<version>4.0.9</version>
	</dependency>
  
  ------------------------------------- TEST DATA HANDLER ----------------------------------------
  ------------------Java Annotation Creation ------------------
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
// TestDataRowNumber.java is the interface name
public @interface TestDataRowNumber {

    @SuppressWarnings("javadoc")
    int rowNumber() default 0;
}
================================== SPREADSHEET DATA PROVIDER STYLE =====================
-------------------------- DATA PROVIDER CLASS CONSTRUCTOR --------------------------------
    private static String WORKBOOK_NAME = "Book1.xlsx";
    private static final String TEST_DATA_PATH = "testDataFilePath"; // key/name in property/configuration file
    private static final String TEST_ENV = "testenv"; // key/name  in property/configuration file

    public DataProviderConstructor() { // name of the data provider class 
        final String testEnv = System.getProperty(TEST_ENV);
        if (!isNullOrWhitespaces(testEnv) && testEnv.equalsIgnoreCase("AlternativeTestEnvironmentName")) {
            WORKBOOK_NAME = "Alternative_Book1.xlsx";
        }
    }
    
  private String setWorkBook(final String workName) {
        return new StringBuilder().append(FrameworkConfig.propertiesFileData(TESTDATAPATH)).append(workName).toString();
    }
    
   public static boolean isNullOrWhitespaces(final String str) {
        if (str == null || str.trim().length() == 0) {
            return true;
        }
        return false;
    }
      
----------------------- TRADITIONAL (ALL TEST DATA AS GROUP TO LOOP THROUGH) -------------------------------
   @DataProvider(name = "dataProviderChoiceName")
    public Object[][] methodName() {
        return new SpreadSheetHandler(setWorkBook("WorkBookName"), "SheetName", false) // if sheet name is not integer
                        .getTestData();
    }

----------------------- INDIVIDUAL ROW (FLEXIBLE TO COMMENT OUT TEST METHOD(S)) ------------------------------
  @DataProvider(name = "dataProviderChoiceName")
    public Object[] methodName(final Method method) {
        final TestDataRowNumber row = method.getAnnotation(RowNumber.class); // TestDataRowNumber: is the annotation Name
        if (row == null) {
            return null;
        }
        //final int rowNum = Integer.parseInt(row.rowNumber()); // if annotation constant return type is a String
        return new SpreadSheetHandler(setWorkBook("WorkBookName"), "SheetName", false).getSingleRow(rowNum);
    }
    
    ------------------------ SPREADSHEET HANDLER ---------------------------
    public class SpreadSheetHandler {

    private static final Logger logger = LoggerFactory.getLogger(SpreadSheetHandler.class);
    public FileInputStream file = null;
    public XSSFWorkbook workbook = null;
    public XSSFSheet sheet = null;
    protected String pathToWorkbookLocation = null;
    protected XSSFRow row = null;
    protected XSSFCell cell = null;
    protected Row rows = null;
    protected Cell cells = null;
    private APPLICATION_SUB_MODULE subModule = null;
    private final String TEST_GROUP = "test_group";
    
     public SpreadSheetHandler(final String workBook, final String excelSheet, final boolean isSheetTypeIndex) {
        this.pathToWorkbookLocation = workBook;
        try {
            file = new FileInputStream(new File(workBook));
            workbook = new XSSFWorkbook(file);
            if(isSheetTypeIndex) {
                final int index = Integer.parseInt(excelSheet);
                sheet = workbook.getSheetAt(index);
            } else {
                sheet = workbook.getSheet(excelSheet);
            }
            file.close();
        } catch(IOException ioe) {
            logger.error("Error opening Spreadsheet file", ioe);
            throw new RuntimeIOException(ioe);
        }

    // APPLICATION_SUB_MODULE : is a ENUM or CLASS that will hold constants
        if (workBook.contains(TEST_GROUP)) {
            subModule = APPLICATION_SUB_MODULE.SUB_MODULE_CONSTANT_NAME;
        }
    
  ------------------------ GET SINGLE ROW METHOD ----------------------------
/**
     * @param rowNum
     */
    public Object[] getDataSetBaseOnRowNumber(final int rowNum) { // Single Row Of data at a time based on row number
        final Object[] dataSets = new Object[1];
        final HashMap<String, String> myMap = new HashMap<String, String>();

        for (int j = 0; j < this.sheet.getRow(0).getLastCellNum(); j++) {
            final XSSFCell cellValue = sheet.getRow(rowNum).getCell(j);

           
                if (cellValue != null) {
                    myMap.put(sheet.getRow(0).getCell(j).toString(), sheet.getRow(rowNum).getCell(j).toString());
                } else {
                    myMap.put(sheet.getRow(0).getCell(j).toString(), "");
                }
            }        

        dataSets[0] = myMap;
        return dataSets;
    }
    
   -------------------------------- GET TEST DATA AS A GROUP --------------------------   
   public Object[][] getTestData() {
         int nonEmptyRows = 0;
         HashMap<Object, Object> tableData = null;
         final int totalRow = sheet.getLastRowNum();
         final int totalColumn = sheet.getRow(0).getLastCellNum();
         final Object[][] dataSets = new Object[totalRow][1];

         for (int i = 0; i < totalRow; i++) {
             tableData = new HashMap<>();
             boolean rowIsNotEmpty = false;
             for (int j = 0; j < totalColumn; j++) {
                 row = sheet.getRow(i + 1);
                 if (row != null) {
                     cell = sheet.getRow(i + 1).getCell(j);
                     if (cell != null && !cell.toString().trim().isEmpty()) {
                         rowIsNotEmpty = true;
                         tableData.put(sheet.getRow(0).getCell(j).toString(), cell.toString());
                     } else {
                         tableData.put(sheet.getRow(0).getCell(j).toString(), "");
                     }
                 }
             }
             if (rowIsNotEmpty) {
                 nonEmptyRows++;
                 dataSets[i][0] = tableData;
             }
         }
         final Object[][] validDataSets = new Object[nonEmptyRows][1];
         if (nonEmptyRows > 0) {
             for (int r = 0; r < nonEmptyRows; r++) {
                 validDataSets[r][0] = dataSets[r][0];
             }
         }
         return validDataSets;
    }
   -------------------------------------------------------------------------------------------
   ====================== Under construction =====================================
   
//	For using a single spreadsheet for all data driven on a dedicated domain/platfdorm	
	public Object[][] getExcelDataBasedOnStartingPoint(String excelLocation, String sheetName, String testName) {
		try {
			String dataSets[][] = null;
			FileInputStream file = new FileInputStream(new File(excelLocation));

			// Create Workbook instance holding reference to .xlsx file
			XSSFWorkbook workbook = new XSSFWorkbook(file);

			// Get first/desired sheet from the workbook
			XSSFSheet sheet = workbook.getSheet(sheetName);
			// count number of active rows
			int totalRow = sheet.getLastRowNum();
			int totalColumn = 0;
			// Iterate through each rows one by one
			Iterator<Row> rowIterator = sheet.iterator();
			int i = 0;
			int count = 1;
			while (rowIterator.hasNext() && count == 1 || count == 2) {
				// System.out.println(i);

				Row row = rowIterator.next();
				// For each row, iterate through all the columns
				Iterator<Cell> cellIterator = row.cellIterator();
				int j = 0;
				while (cellIterator.hasNext()) {

					Cell cell = cellIterator.next();

					if (cell.getStringCellValue().contains(testName + "end")) {
						count = 0;
						break;
					}

					// System.out.println(sheetName+"Start");
					if (cell.getStringCellValue().contains(testName + "start")) {
						// count number of active columns in row
						totalColumn = row.getPhysicalNumberOfCells() - 1;
						// Create array of rows and column
						dataSets = new String[totalRow][totalColumn];
					}
					// System.out.println(sheetName+"Start");
					if (cell.getStringCellValue().contains(testName + "start") || count == 2) {
						System.out.println(sheetName + "start");
						count = 2;
						// Check the cell type and format accordingly

						switch (cell.getCellType()) {
						case Cell.CELL_TYPE_NUMERIC:
							dataSets[i - 1][j++] = cell.getStringCellValue();
							System.out.println(cell.getNumericCellValue());
							break;
						case Cell.CELL_TYPE_STRING:
							if (!cell.getStringCellValue().contains(testName + "start")) {
								dataSets[i - 1][j++] = cell.getStringCellValue();
								System.out.println(cell.getStringCellValue());
							}
							break;
						case Cell.CELL_TYPE_BOOLEAN:
							dataSets[i - 1][j++] = cell.getStringCellValue();
							System.out.println(cell.getStringCellValue());
							break;
						case Cell.CELL_TYPE_FORMULA:
							dataSets[i - 1][j++] = cell.getStringCellValue();
							System.out.println(cell.getStringCellValue());
							break;
						}

					}
				}

				System.out.println("");
				i++;
			}
			file.close();

			return parseData(dataSets, totalColumn);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	/**
	 * This method is used to remove unwanted null data from array
	 * 
	 * @param data
	 * @return
	 */
	public Object[][] parseData(Object[][] data, int colSize) {
		// Creating array list to store data;
		ArrayList<ArrayList<String>> list = new ArrayList<ArrayList<String>>();

		// This array list will store one Array index data, every array index
		// has three sets of data
		ArrayList<String> list1;

		System.out.println(data.length);

		// running for loop on array size
		for (int i = 0; i < data.length; i++) {
			// creates a list to store the elements != null

			System.out.println(data[i].length);

			list1 = new ArrayList<String>();
			// this for loop will run on array index, since each array index has
			// three sets of data
			for (int j = 0; j < data[i].length; j++) {
				// this if will check null
				if (data[i][j] != null) {
					list1.add((String) data[i][j]);
				}
			}
			// once all one array index data is entered in arrayList , then
			// putting this object in parent arrayList
			if (list1.size() > 0) {
				list.add(list1);
			}
		}
		// convert array List Data into 2D Array
		Object[][] arr2d = new Object[list.size()][colSize];
		// run loop on array list data
		for (int i = 0; i < list.size(); i++) {
			// every array list index has arryList inside
			ArrayList<String> t = list.get(i);
			// run loop on inner array List
			for (int j = 0; j < t.size(); j++) {
				arr2d[i][j] = t.get(j);
			}
		}
		System.out.println(list);
		System.out.println(arr2d);
		return arr2d;
	}
   
   =========================== JSON Test Data handler ===========================
    // Add this dependency or download and add the googlecode.json-simple jar file
    <!-- https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple -->
    <dependency>
        <groupId>com.googlecode.json-simple</groupId>
        <artifactId>json-simple</artifactId>
        <version>1.1.1</version>
    </dependency>
  
    @DataProvider(name = "jsonArrayStringDataReturner")
    private String[]  getStringArrayOfTestDataInGroup(final Method method) {
        String array[] = null;
        try {
            String filePath =  "jsonFilePath/fileName.json";
            JSONParser jsonParser = new JSONParser();
            FileReader reader = new FileReader(filePath);
            Object readData = jsonParser.parse(reader);
            JSONObject testData = (JSONObject) readData;
            // To get JSON Array data--- >
            JSONArray arrayObject = (JSONArray) testData.get("JSON Array key"); 
            array = new String[arrayObject.size()];
            // loop through the array
            for(int i = 0; i < arrayObject.size(); i++) {
            JSONObject arrayData = (JSONObject) arrayObject.get(i);              
                array[i] = new StringBuilder().append(arrayData.get("fieldKey1").toString()).append(",")
                         .append((String) arrayData.get("fieldKey2")).append(",").append("fieldKey...n").toString();
            }    
        } catch (IOException ioe) {
            ioe.getMessage();
        } catch (ParseException pe) {
            pe.getMessage();
        } 
        return  array; 
    }    
    
    // Sample test with the array string test data.
    @Test(priority = 1, dataProvider = "jsonArrayStringDataReturner", dataProviderClass = nameOfDataProviderClass.class)
    private void usingJsonArrayStringDataReturned(final String testData) {
        // Use below split variable to populate respective fields if testData is a strip but not a hash map
        String inputData[] = testData.split(",");        // pass the split data as input value using the index
        launchBrowserAndGoToApplicationPage() // url is configuration class or file
                    .clickSignUpLink().enterUserName(inputData[0])
                    .enterPassword(inputData[1])
                    .confirmPassword(inputData[2])
                    .clickSubmitButton()
                    .verifyApplicationSubmission(inputData[3]) // expected message is stored in the test data
                    .logOut();
        assertAll(); // inherited softAssert method from test base class. 
    }
    
    @DataProvider(name = "jsonGroupHashMapDataReturner")
    private Object[]  getHashMapGroupOfTestData(final Method method)   {
        JSONArray arrayObject = null;
        try {
            String filePath =  "jsonFilePath/fileName.json";
            JSONParser jsonParser = new JSONParser();        
            FileReader reader = new FileReader(filePath);
            Object readData = jsonParser.parse(reader);
            JSONObject testData = (JSONObject) readData;            
          // To get JSON Array --- >
             arrayObject = (JSONArray) testData.get("JSON Array key"); 
        } catch (IOException ioe) {
            ioe.getMessage();
        } catch (ParseException pe) {
            pe.getMessage();
        } 
        return  arrayObject.toArray(); 
    }

    @Test(priority = 1, dataProvider = "jsonGroupHashMapDataReturner", dataProviderClass = nameOfDataProviderClass.class)
    private void usingGroupedJsonHashMapDataReturned(final Map<String, String> testData) {
        launchBrowserAndGoToApplicationPage() // url is configuration class or file
                 .clickSignUpLink().enterUserName(testData)
                 .enterPassword(testData)
                 .confirmPassword(testData)
                 .clickSubmitButton()
                 .verifyApplicationSubmission(testData) // expected message is stored in the test data
                .logOut();
        assertAll(); // inherited softAssert method from test base class
    }
    
    @DataProvider(name = "jsonGroupHashMapWithTestDataIndexReturner")
    private Object[] getHashMapGroupOfTestDataByRowIndex(final Method method)   {
        JSONArray arrayObject = null;
        try {
            String filePath =  "jsonFilePath/fileName.json";
            JSONParser jsonParser = new JSONParser();        
            FileReader reader = new FileReader(filePath);
            Object readData = jsonParser.parse(reader);
            JSONObject testData = (JSONObject) readData;            
          // To handle JSON Array --- >
             arrayObject = (JSONArray) testData.get("wjvTestData"); // "JSON Array key"             
        } catch (IOException ioe) {
            ioe.getMessage();
        } catch (ParseException pe) {
            pe.getMessage();
        } 
        
        Object[] testData= new Object[1];
        int rowNumber = method.getAnnotation(RowNumber.class).testDataRowNumber()-1;
        if(rowNumber < 0 || rowNumber > arrayObject.size()) {
            LOGGER.info("Invalid test data row number entered, please enter valid test (Array Object position) number."); 
        }
        testData[0]=arrayObject.toArray()[rowNumber];
        return   testData;  
    }
    
    @RowNumber(testDataRowNumber = 1)
    @Test(priority = 1, dataProvider = "jsonGroupHashMapWithTestDataIndexReturner", dataProviderClass = nameOfDataProviderClass.class)
    private void usingTestDataReturnedIndexOfGroupHashMapData(final Map<String, String> testData) {
        launchBrowserAndGoToApplicationPage() // url is configuration class or file
                 .clickSignUpLink().enterUserName(testData)
                 .enterPassword(testData)
                 .confirmPassword(testData)
                 .clickSubmitButton()
                 .verifyApplicationSubmission(testData) // expected message is stored in the test data
                .logOut();
        assertAll(); // inherited softAssert method from test base class
    }
    
   -----------------------------------------------------------------------------------
   // generate random character base on specidfied size/count
    private String randomAlphabets(final int stringCharacterSize) {
        return RandomStringUtils.randomAlphabetic(stringCharacterSize);
    }
